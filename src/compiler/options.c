/**
 * \file
 *
 * \copyright Copyright (c) 2023 Róna Balázs. All rights reserved.
 * \license This project is released under the Apache 2.0 license.
 */

#include "compiler/options.h"

#include "utils/io/argparse.h"

/**
 * \brief Enumeration of compiler option kinds.
 */
typedef enum options_option_kind_t
{
  OPTION_HELP,              ///< -h, --help
  OPTION_VERSION,           ///< --version
  OPTION_VERBOSE,           ///< -v, --verbose
  OPTION_LOG_LEVEL,         ///< --log-level <LEVEL>
  OPTION_OUTPUT,            ///< -o, --output <FILE>
  OPTION_OUTPUT_KIND,       ///< --output-kind <KIND>
  OPTION_DUMP_TOKENS,       ///< --dump-tokens
  OPTION_DUMP_AST,          ///< --dump-ast
  OPTION_DUMP_LL,           ///< --dump-ll
  OPTION_DUMP_BC,           ///< --dump-bc
  OPTION_DUMP_ASM,          ///< --dump-asm
  OPTION_DYNAMIC,           ///< --dynamic
  OPTION_STATIC,            ///< --static
  OPTION_LIBRARY,           ///< -l <LIB>
  OPTION_LIBRARY_DIRECTORY, ///< -L <DIR>
  OPTION_PIE,               ///< --pie
  OPTION_NO_PIE,            ///< --no-pie
} options_option_kind_t;

/**
 * \brief Array of command-line options for argparse.
 */
static const argparse_option_t g_argparse_opts[] = {
  ARGPARSE_OPTION(OPTION_HELP,              "h",  "help",        NULL,    "Display this help message and exit."),
  ARGPARSE_OPTION(OPTION_VERSION,           NULL, "version",     NULL,    "Show the program version and exit."),
  ARGPARSE_OPTION(OPTION_VERBOSE,           "v",  "verbose",     NULL,    "Enable verbose mode for more detailed output."),
  ARGPARSE_OPTION(OPTION_LOG_LEVEL,         NULL, "log-level",   "LEVEL", "Set the logging level (e.g., debug, info, warn, error)."),
  ARGPARSE_OPTION(OPTION_OUTPUT,            "o",  "output",      "FILE",  "Specify the output file name."),
  ARGPARSE_OPTION(OPTION_OUTPUT_KIND,       NULL, "output-kind", "KIND",  "Specify the type of output (e.g., exec, pie, dyn)."),
  ARGPARSE_OPTION(OPTION_DUMP_TOKENS,       NULL, "dump-tokens", NULL,    "Output the list of tokens generated by the lexer."),
  ARGPARSE_OPTION(OPTION_DUMP_AST,          NULL, "dump-ast",    NULL,    "Output the abstract syntax tree (AST) after parsing."),
  ARGPARSE_OPTION(OPTION_DUMP_LL,           NULL, "dump-ll",     NULL,    "Output the generated LLVM intermediate representation (IR)."),
  ARGPARSE_OPTION(OPTION_DUMP_BC,           NULL, "dump-bc",     NULL,    "Output the generated LLVM bitcode."),
  ARGPARSE_OPTION(OPTION_DUMP_ASM,          NULL, "dump-asm",    NULL,    "Output the generated assembly code."),
  ARGPARSE_OPTION(OPTION_LIBRARY,           "l",  NULL,          "LIB",   "Link with the specified library by name."),
  ARGPARSE_OPTION(OPTION_LIBRARY_DIRECTORY, "L",  NULL,          "DIR",   "Add the specified directory to the library search path."),
  ARGPARSE_OPTION(OPTION_PIE,               NULL, "pie",         NULL,    "Generate a position-independent executable (PIE)."),
  ARGPARSE_OPTION(OPTION_NO_PIE,            NULL, "no-pie",      NULL,    "Generate a non-position-independent executable.")
};

/**
 * \brief Enumeration of compiler output kinds.
 */
typedef enum options_output_kind_t
{
  OPTIONS_OUTPUT_EXECUTABLE,
  OPTIONS_OUTPUT_DYNAMIC_LIBRARY,
} options_output_kind_t;

/**
 * \brief Enumeration of linking method kinds.
 */
typedef enum options_link_kind_t
{
  OPTIONS_LINK_STATIC,
  OPTIONS_LINK_DYNAMIC,
} options_link_kind_t;

struct options_ctx_t
{
  const char* output_file;

  log_level_t log_level;
  options_output_kind_t output_kind;
  options_link_kind_t link_kind;

  vector_t* libs;
  vector_t* search_dirs;
  vector_t* input_files;

  bool is_verbose;
  bool dump_tokens;
  bool dump_ast;
  bool dump_ll;
  bool dump_bc;
  bool dump_asm;
  bool is_pie;

  bool should_exit;
};

static void options_option_help(options_ctx_t* ctx, argparse_ctx_t* argp_ctx)
{
  puts("Usage: tauc [OPTIONS...] <FILES...>\n");

  argparse_print_options(argp_ctx, stdout);

  ctx->should_exit = true;
}

static void options_option_version(options_ctx_t* ctx)
{
  puts(TAU_VERSION);

  ctx->should_exit = true;
}

static void options_option_verbose(options_ctx_t* ctx)
{
  ctx->is_verbose = true;
}

static void options_option_log_level(options_ctx_t* ctx, argparse_ctx_t* argp_ctx)
{
  const char* arg = argparse_next_arg(argp_ctx);

  if (strcmp("trace", arg) == 0 || strcmp("0", arg) == 0)
    ctx->log_level = LOG_LEVEL_TRACE;
  else if (strcmp("debug", arg) == 0 || strcmp("1", arg) == 0)
    ctx->log_level = LOG_LEVEL_DEBUG;
  else if (strcmp("info", arg) == 0 || strcmp("2", arg) == 0)
    ctx->log_level = LOG_LEVEL_INFO;
  else if (strcmp("warn", arg) == 0 || strcmp("3", arg) == 0)
    ctx->log_level = LOG_LEVEL_WARN;
  else if (strcmp("error", arg) == 0 || strcmp("4", arg) == 0)
    ctx->log_level = LOG_LEVEL_ERROR;
  else if (strcmp("fatal", arg) == 0 || strcmp("5", arg) == 0)
    ctx->log_level = LOG_LEVEL_FATAL;
  else
    UNREACHABLE();
}

static void options_option_output(options_ctx_t* ctx, argparse_ctx_t* argp_ctx)
{
  ctx->output_file = argparse_next_arg(argp_ctx);
}

static void options_option_output_kind(options_ctx_t* ctx, argparse_ctx_t* argp_ctx)
{
  const char* arg = argparse_next_arg(argp_ctx);

  if (strcmp("exec", arg) == 0)
    ctx->output_kind = OPTIONS_OUTPUT_EXECUTABLE;
  else if (strcmp("dyn", arg) == 0)
    ctx->output_kind = OPTIONS_OUTPUT_DYNAMIC_LIBRARY;
  else
    UNREACHABLE();
}

static void options_option_dump_tokens(options_ctx_t* ctx)
{
  ctx->dump_tokens = true;
}

static void options_option_dump_ast(options_ctx_t* ctx)
{
  ctx->dump_ast = true;
}

static void options_option_dump_ll(options_ctx_t* ctx)
{
  ctx->dump_ll = true;
}

static void options_option_dump_bc(options_ctx_t* ctx)
{
  ctx->dump_bc = true;
}

static void options_option_dump_asm(options_ctx_t* ctx)
{
  ctx->dump_asm = true;
}

static void options_option_dynamic(options_ctx_t* ctx)
{
  ctx->link_kind = OPTIONS_LINK_DYNAMIC;
}

static void options_option_static(options_ctx_t* ctx)
{
  ctx->link_kind = OPTIONS_LINK_STATIC;
}

static void options_option_library(options_ctx_t* ctx, argparse_ctx_t* argp_ctx)
{
  vector_push(ctx->libs, (void*)argparse_next_arg(argp_ctx));
}

static void options_option_library_directory(options_ctx_t* ctx, argparse_ctx_t* argp_ctx)
{
  vector_push(ctx->search_dirs, (void*)argparse_next_arg(argp_ctx));
}

static void options_option_pie(options_ctx_t* ctx)
{
  ctx->is_pie = true;
}

static void options_option_no_pie(options_ctx_t* ctx)
{
  ctx->is_pie = false;
}

static void options_input_file(options_ctx_t* ctx, argparse_ctx_t* argp_ctx)
{
  vector_push(ctx->input_files, (void*)argparse_get_arg_at(argp_ctx, argparse_get_index(argp_ctx) - 1));
}

options_ctx_t* options_ctx_init(void)
{
  options_ctx_t* ctx = (options_ctx_t*)malloc(sizeof(options_ctx_t));

  ctx->output_file = "a";
  ctx->log_level = LOG_LEVEL_WARN;
  ctx->output_kind = OPTIONS_OUTPUT_EXECUTABLE;
  ctx->link_kind = OPTIONS_LINK_DYNAMIC;
  ctx->libs = vector_init();
  ctx->search_dirs = vector_init();
  ctx->input_files = vector_init();
  ctx->is_verbose = false;
  ctx->dump_tokens = false;
  ctx->dump_ast = false;
  ctx->dump_ll = false;
  ctx->dump_bc = false;
  ctx->dump_asm = false;
  ctx->is_pie = true;
  ctx->should_exit = false;

  return ctx;
}

void options_ctx_free(options_ctx_t* ctx)
{
  vector_free(ctx->libs);
  vector_free(ctx->search_dirs);
  vector_free(ctx->input_files);
  free(ctx);
}

void options_parse(options_ctx_t* ctx, int argc, const char* argv[])
{
  argparse_ctx_t* argp_ctx = argparse_ctx_init(g_argparse_opts, COUNTOF(g_argparse_opts), argv, argc);

  int opt_id;

  while (!ctx->should_exit && (opt_id = argparse_fetch(argp_ctx)) != ARGPARSE_EOA)
  {
    switch (opt_id)
    {
    case OPTION_HELP:              options_option_help             (ctx, argp_ctx); break;
    case OPTION_VERSION:           options_option_version          (ctx          ); break;
    case OPTION_VERBOSE:           options_option_verbose          (ctx          ); break;
    case OPTION_LOG_LEVEL:         options_option_log_level        (ctx, argp_ctx); break;
    case OPTION_OUTPUT:            options_option_output           (ctx, argp_ctx); break;
    case OPTION_OUTPUT_KIND:       options_option_output_kind      (ctx, argp_ctx); break;
    case OPTION_DUMP_TOKENS:       options_option_dump_tokens      (ctx          ); break;
    case OPTION_DUMP_AST:          options_option_dump_ast         (ctx          ); break;
    case OPTION_DUMP_LL:           options_option_dump_ll          (ctx          ); break;
    case OPTION_DUMP_BC:           options_option_dump_bc          (ctx          ); break;
    case OPTION_DUMP_ASM:          options_option_dump_asm         (ctx          ); break;
    case OPTION_DYNAMIC:           options_option_dynamic          (ctx          ); break;
    case OPTION_STATIC:            options_option_static           (ctx          ); break;
    case OPTION_LIBRARY:           options_option_library          (ctx, argp_ctx); break;
    case OPTION_LIBRARY_DIRECTORY: options_option_library_directory(ctx, argp_ctx); break;
    case OPTION_PIE:               options_option_pie              (ctx          ); break;
    case OPTION_NO_PIE:            options_option_no_pie           (ctx          ); break;
    case ARGPARSE_UNKNOWN:         options_input_file              (ctx, argp_ctx); break;
    default: UNREACHABLE();
    }
  }

  argparse_ctx_free(argp_ctx);
}

const char* options_get_output_file(options_ctx_t* ctx)
{
  return ctx->output_file;
}

linker_output_kind_t options_get_output_kind(options_ctx_t* ctx)
{
  if (ctx->output_kind == OPTIONS_OUTPUT_EXECUTABLE && ctx->link_kind == OPTIONS_LINK_DYNAMIC && ctx->is_pie)
    return LINKER_OUTPUT_DYNAMIC_PIE;

  if (ctx->output_kind == OPTIONS_OUTPUT_EXECUTABLE && ctx->link_kind == OPTIONS_LINK_DYNAMIC && !ctx->is_pie)
    return LINKER_OUTPUT_DYNAMIC_NONPIE;

  if (ctx->output_kind == OPTIONS_OUTPUT_EXECUTABLE && ctx->link_kind == OPTIONS_LINK_STATIC && ctx->is_pie)
    return LINKER_OUTPUT_STATIC_PIE;

  if (ctx->output_kind == OPTIONS_OUTPUT_EXECUTABLE && ctx->link_kind == OPTIONS_LINK_STATIC && !ctx->is_pie)
    return LINKER_OUTPUT_STATIC_NONPIE;

  if (ctx->output_kind == OPTIONS_OUTPUT_DYNAMIC_LIBRARY)
    return LINKER_OUTPUT_DYNAMIC_LIBRARY;

  UNREACHABLE();

  return -1;
}

log_level_t options_get_log_level(options_ctx_t* ctx)
{
  return ctx->log_level;
}

vector_t* options_get_link_libraries(options_ctx_t* ctx)
{
  return ctx->libs;
}

vector_t* options_get_search_directories(options_ctx_t* ctx)
{
  return ctx->search_dirs;
}

vector_t* options_get_input_files(options_ctx_t* ctx)
{
  return ctx->input_files;
}

bool options_get_is_verbose(options_ctx_t* ctx)
{
  return ctx->is_verbose;
}

bool options_get_dump_tokens(options_ctx_t* ctx)
{
  return ctx->dump_tokens;
}

bool options_get_dump_ast(options_ctx_t* ctx)
{
  return ctx->dump_ast;
}

bool options_get_dump_ll(options_ctx_t* ctx)
{
  return ctx->dump_ll;
}

bool options_get_dump_bc(options_ctx_t* ctx)
{
  return ctx->dump_bc;
}

bool options_get_dump_asm(options_ctx_t* ctx)
{
  return ctx->dump_asm;
}

bool options_get_should_exit(options_ctx_t* ctx)
{
  return ctx->should_exit;
}
