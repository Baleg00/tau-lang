/**
 * \file
 *
 * \copyright Copyright (c) 2023 Róna Balázs. All rights reserved.
 * \license This project is released under the Apache 2.0 license.
 */

#include "compiler/options.h"

#include "utils/io/argparse.h"

/**
 * \brief Enumeration of compiler option kinds.
 */
typedef enum tau_options_option_kind_t
{
  OPTION_HELP,              ///< -h, --help
  OPTION_VERSION,           ///< --version
  OPTION_VERBOSE,           ///< -v, --verbose
  OPTION_LOG_LEVEL,         ///< --log-level <LEVEL>
  OPTION_OUTPUT,            ///< -o, --output <FILE>
  OPTION_OUTPUT_KIND,       ///< --output-kind <KIND>
  OPTION_DUMP_TOKENS,       ///< --dump-tokens
  OPTION_DUMP_AST,          ///< --dump-ast
  OPTION_DUMP_LL,           ///< --dump-ll
  OPTION_DUMP_BC,           ///< --dump-bc
  OPTION_DUMP_ASM,          ///< --dump-asm
  OPTION_DYNAMIC,           ///< --dynamic
  OPTION_STATIC,            ///< --static
  OPTION_LIBRARY,           ///< -l <LIB>
  OPTION_LIBRARY_DIRECTORY, ///< -L <DIR>
  OPTION_PIE,               ///< --pie
  OPTION_NO_PIE,            ///< --no-pie
} tau_options_option_kind_t;

/**
 * \brief Array of command-line options for argparse.
 */
static const tau_argparse_option_t g_argparse_opts[] = {
  TAU_ARGPARSE_OPTION(OPTION_HELP,              "h",  "help",        NULL,    "Display this help message and exit."),
  TAU_ARGPARSE_OPTION(OPTION_VERSION,           NULL, "version",     NULL,    "Show the program version and exit."),
  TAU_ARGPARSE_OPTION(OPTION_VERBOSE,           "v",  "verbose",     NULL,    "Enable verbose mode for more detailed output."),
  TAU_ARGPARSE_OPTION(OPTION_LOG_LEVEL,         NULL, "log-level",   "LEVEL", "Set the logging level (e.g., debug, info, warn, error)."),
  TAU_ARGPARSE_OPTION(OPTION_OUTPUT,            "o",  "output",      "FILE",  "Specify the output file name."),
  TAU_ARGPARSE_OPTION(OPTION_OUTPUT_KIND,       NULL, "output-kind", "KIND",  "Specify the type of output (e.g., exec, pie, dyn)."),
  TAU_ARGPARSE_OPTION(OPTION_DUMP_TOKENS,       NULL, "dump-tokens", NULL,    "Output the list of tokens generated by the lexer."),
  TAU_ARGPARSE_OPTION(OPTION_DUMP_AST,          NULL, "dump-ast",    NULL,    "Output the abstract syntax tree (AST) after parsing."),
  TAU_ARGPARSE_OPTION(OPTION_DUMP_LL,           NULL, "dump-ll",     NULL,    "Output the generated LLVM intermediate representation (IR)."),
  TAU_ARGPARSE_OPTION(OPTION_DUMP_BC,           NULL, "dump-bc",     NULL,    "Output the generated LLVM bitcode."),
  TAU_ARGPARSE_OPTION(OPTION_DUMP_ASM,          NULL, "dump-asm",    NULL,    "Output the generated assembly code."),
  TAU_ARGPARSE_OPTION(OPTION_LIBRARY,           "l",  NULL,          "LIB",   "Link with the specified library by name."),
  TAU_ARGPARSE_OPTION(OPTION_LIBRARY_DIRECTORY, "L",  NULL,          "DIR",   "Add the specified directory to the library search path."),
  TAU_ARGPARSE_OPTION(OPTION_PIE,               NULL, "pie",         NULL,    "Generate a position-independent executable (PIE)."),
  TAU_ARGPARSE_OPTION(OPTION_NO_PIE,            NULL, "no-pie",      NULL,    "Generate a non-position-independent executable.")
};

/**
 * \brief Enumeration of compiler output kinds.
 */
typedef enum tau_options_output_kind_t
{
  OPTIONS_OUTPUT_EXECUTABLE,
  OPTIONS_OUTPUT_DYNAMIC_LIBRARY,
} tau_options_output_kind_t;

/**
 * \brief Enumeration of linking method kinds.
 */
typedef enum tau_options_link_kind_t
{
  OPTIONS_LINK_STATIC,
  OPTIONS_LINK_DYNAMIC,
} tau_options_link_kind_t;

struct tau_options_ctx_t
{
  const char* output_file;

  tau_log_level_t level;
  tau_options_output_kind_t output_kind;
  tau_options_link_kind_t link_kind;

  tau_vector_t* libs;
  tau_vector_t* search_dirs;
  tau_vector_t* input_files;

  bool is_verbose;
  bool dump_tokens;
  bool dump_ast;
  bool dump_ll;
  bool dump_bc;
  bool dump_asm;
  bool is_pie;

  bool should_exit;
};

static void tau_options_option_help(tau_options_ctx_t* ctx, tau_argparse_ctx_t* argp_ctx)
{
  puts("Usage: tauc [OPTIONS...] <FILES...>\n");

  tau_argparse_print_options(argp_ctx, stdout);

  ctx->should_exit = true;
}

static void tau_options_option_version(tau_options_ctx_t* ctx)
{
  puts(TAU_VERSION);

  ctx->should_exit = true;
}

static void tau_options_option_verbose(tau_options_ctx_t* ctx)
{
  ctx->is_verbose = true;
}

static void tau_options_option_log_level(tau_options_ctx_t* ctx, tau_argparse_ctx_t* argp_ctx)
{
  const char* arg = tau_argparse_next_arg(argp_ctx);

  if (strcmp("trace", arg) == 0 || strcmp("0", arg) == 0)
    ctx->level = TAU_LOG_LEVEL_TRACE;
  else if (strcmp("debug", arg) == 0 || strcmp("1", arg) == 0)
    ctx->level = TAU_LOG_LEVEL_DEBUG;
  else if (strcmp("info", arg) == 0 || strcmp("2", arg) == 0)
    ctx->level = TAU_LOG_LEVEL_INFO;
  else if (strcmp("warn", arg) == 0 || strcmp("3", arg) == 0)
    ctx->level = TAU_LOG_LEVEL_WARN;
  else if (strcmp("error", arg) == 0 || strcmp("4", arg) == 0)
    ctx->level = TAU_LOG_LEVEL_ERROR;
  else if (strcmp("fatal", arg) == 0 || strcmp("5", arg) == 0)
    ctx->level = TAU_LOG_LEVEL_FATAL;
  else
    TAU_UNREACHABLE();
}

static void tau_options_option_output(tau_options_ctx_t* ctx, tau_argparse_ctx_t* argp_ctx)
{
  ctx->output_file = tau_argparse_next_arg(argp_ctx);
}

static void tau_options_option_output_kind(tau_options_ctx_t* ctx, tau_argparse_ctx_t* argp_ctx)
{
  const char* arg = tau_argparse_next_arg(argp_ctx);

  if (strcmp("exec", arg) == 0)
    ctx->output_kind = OPTIONS_OUTPUT_EXECUTABLE;
  else if (strcmp("dyn", arg) == 0)
    ctx->output_kind = OPTIONS_OUTPUT_DYNAMIC_LIBRARY;
  else
    TAU_UNREACHABLE();
}

static void tau_options_option_dump_tokens(tau_options_ctx_t* ctx)
{
  ctx->dump_tokens = true;
}

static void tau_options_option_dump_ast(tau_options_ctx_t* ctx)
{
  ctx->dump_ast = true;
}

static void tau_options_option_dump_ll(tau_options_ctx_t* ctx)
{
  ctx->dump_ll = true;
}

static void tau_options_option_dump_bc(tau_options_ctx_t* ctx)
{
  ctx->dump_bc = true;
}

static void tau_options_option_dump_asm(tau_options_ctx_t* ctx)
{
  ctx->dump_asm = true;
}

static void tau_options_option_dynamic(tau_options_ctx_t* ctx)
{
  ctx->link_kind = OPTIONS_LINK_DYNAMIC;
}

static void tau_options_option_static(tau_options_ctx_t* ctx)
{
  ctx->link_kind = OPTIONS_LINK_STATIC;
}

static void tau_options_option_library(tau_options_ctx_t* ctx, tau_argparse_ctx_t* argp_ctx)
{
  tau_vector_push(ctx->libs, (void*)tau_argparse_next_arg(argp_ctx));
}

static void tau_options_option_library_directory(tau_options_ctx_t* ctx, tau_argparse_ctx_t* argp_ctx)
{
  tau_vector_push(ctx->search_dirs, (void*)tau_argparse_next_arg(argp_ctx));
}

static void tau_options_option_pie(tau_options_ctx_t* ctx)
{
  ctx->is_pie = true;
}

static void tau_options_option_no_pie(tau_options_ctx_t* ctx)
{
  ctx->is_pie = false;
}

static void tau_options_input_file(tau_options_ctx_t* ctx, tau_argparse_ctx_t* argp_ctx)
{
  tau_vector_push(ctx->input_files, (void*)tau_argparse_get_arg_at(argp_ctx, tau_argparse_get_index(argp_ctx) - 1));
}

tau_options_ctx_t* tau_options_ctx_init(void)
{
  tau_options_ctx_t* ctx = (tau_options_ctx_t*)malloc(sizeof(tau_options_ctx_t));

  ctx->output_file = "a";
  ctx->level = TAU_LOG_LEVEL_WARN;
  ctx->output_kind = OPTIONS_OUTPUT_EXECUTABLE;
  ctx->link_kind = OPTIONS_LINK_DYNAMIC;
  ctx->libs = tau_vector_init();
  ctx->search_dirs = tau_vector_init();
  ctx->input_files = tau_vector_init();
  ctx->is_verbose = false;
  ctx->dump_tokens = false;
  ctx->dump_ast = false;
  ctx->dump_ll = false;
  ctx->dump_bc = false;
  ctx->dump_asm = false;
  ctx->is_pie = true;
  ctx->should_exit = false;

  return ctx;
}

void tau_options_ctx_free(tau_options_ctx_t* ctx)
{
  tau_vector_free(ctx->libs);
  tau_vector_free(ctx->search_dirs);
  tau_vector_free(ctx->input_files);
  free(ctx);
}

void tau_options_parse(tau_options_ctx_t* ctx, int argc, const char* argv[])
{
  tau_argparse_ctx_t* argp_ctx = tau_argparse_ctx_init(g_argparse_opts, TAU_COUNTOF(g_argparse_opts), argv, argc);

  int opt_id;

  while (!ctx->should_exit && (opt_id = tau_argparse_fetch(argp_ctx)) != TAU_ARGPARSE_EOA)
  {
    switch (opt_id)
    {
    case OPTION_HELP:              tau_options_option_help             (ctx, argp_ctx); break;
    case OPTION_VERSION:           tau_options_option_version          (ctx          ); break;
    case OPTION_VERBOSE:           tau_options_option_verbose          (ctx          ); break;
    case OPTION_LOG_LEVEL:         tau_options_option_log_level        (ctx, argp_ctx); break;
    case OPTION_OUTPUT:            tau_options_option_output           (ctx, argp_ctx); break;
    case OPTION_OUTPUT_KIND:       tau_options_option_output_kind      (ctx, argp_ctx); break;
    case OPTION_DUMP_TOKENS:       tau_options_option_dump_tokens      (ctx          ); break;
    case OPTION_DUMP_AST:          tau_options_option_dump_ast         (ctx          ); break;
    case OPTION_DUMP_LL:           tau_options_option_dump_ll          (ctx          ); break;
    case OPTION_DUMP_BC:           tau_options_option_dump_bc          (ctx          ); break;
    case OPTION_DUMP_ASM:          tau_options_option_dump_asm         (ctx          ); break;
    case OPTION_DYNAMIC:           tau_options_option_dynamic          (ctx          ); break;
    case OPTION_STATIC:            tau_options_option_static           (ctx          ); break;
    case OPTION_LIBRARY:           tau_options_option_library          (ctx, argp_ctx); break;
    case OPTION_LIBRARY_DIRECTORY: tau_options_option_library_directory(ctx, argp_ctx); break;
    case OPTION_PIE:               tau_options_option_pie              (ctx          ); break;
    case OPTION_NO_PIE:            tau_options_option_no_pie           (ctx          ); break;
    case TAU_ARGPARSE_UNKNOWN:         tau_options_input_file              (ctx, argp_ctx); break;
    default: TAU_UNREACHABLE();
    }
  }

  tau_argparse_ctx_free(argp_ctx);
}

const char* tau_options_get_output_file(tau_options_ctx_t* ctx)
{
  return ctx->output_file;
}

tau_linker_output_kind_t tau_options_get_output_kind(tau_options_ctx_t* ctx)
{
  if (ctx->output_kind == OPTIONS_OUTPUT_EXECUTABLE && ctx->link_kind == OPTIONS_LINK_DYNAMIC && ctx->is_pie)
    return TAU_LINKER_OUTPUT_DYNAMIC_PIE;

  if (ctx->output_kind == OPTIONS_OUTPUT_EXECUTABLE && ctx->link_kind == OPTIONS_LINK_DYNAMIC && !ctx->is_pie)
    return TAU_LINKER_OUTPUT_DYNAMIC_NONPIE;

  if (ctx->output_kind == OPTIONS_OUTPUT_EXECUTABLE && ctx->link_kind == OPTIONS_LINK_STATIC && ctx->is_pie)
    return TAU_LINKER_OUTPUT_STATIC_PIE;

  if (ctx->output_kind == OPTIONS_OUTPUT_EXECUTABLE && ctx->link_kind == OPTIONS_LINK_STATIC && !ctx->is_pie)
    return TAU_LINKER_OUTPUT_STATIC_NONPIE;

  if (ctx->output_kind == OPTIONS_OUTPUT_DYNAMIC_LIBRARY)
    return TAU_LINKER_OUTPUT_DYNAMIC_LIBRARY;

  TAU_UNREACHABLE();

  return -1;
}

tau_log_level_t tau_options_get_log_level(tau_options_ctx_t* ctx)
{
  return ctx->level;
}

tau_vector_t* tau_options_get_link_libraries(tau_options_ctx_t* ctx)
{
  return ctx->libs;
}

tau_vector_t* tau_options_get_search_directories(tau_options_ctx_t* ctx)
{
  return ctx->search_dirs;
}

tau_vector_t* tau_options_get_input_files(tau_options_ctx_t* ctx)
{
  return ctx->input_files;
}

bool tau_options_get_is_verbose(tau_options_ctx_t* ctx)
{
  return ctx->is_verbose;
}

bool tau_options_get_dump_tokens(tau_options_ctx_t* ctx)
{
  return ctx->dump_tokens;
}

bool tau_options_get_dump_ast(tau_options_ctx_t* ctx)
{
  return ctx->dump_ast;
}

bool tau_options_get_dump_ll(tau_options_ctx_t* ctx)
{
  return ctx->dump_ll;
}

bool tau_options_get_dump_bc(tau_options_ctx_t* ctx)
{
  return ctx->dump_bc;
}

bool tau_options_get_dump_asm(tau_options_ctx_t* ctx)
{
  return ctx->dump_asm;
}

bool tau_options_get_should_exit(tau_options_ctx_t* ctx)
{
  return ctx->should_exit;
}
